# Bilingual (Mesgjs And JavaScript) Interface Development

## Module Template

A Mesgjs module consists of a `.msjs` main source file and an optional `.slid` file for external SLID-format configuration (typically only required for recording module dependency information).

### The Mesgjs Source File (`.msjs`)

```javascript
[(
/*
 * This is the inline configuration SLID (static list data).
 * It contains version-immutable configuration information needed by the tranpilation and loading tools.
 */
modpath=collection/some/path/module-name
version=major.minor.patch
featreq='optional list of feature dependencies'
featpro='optional list of features provided'
modcaps='optional list of requested module capabilities'
)]

@js{
/* Outer JS embed. This code appears at the top-level of the transpiled module. This entire embed can generally be omitted. */
@}
'' // <-- This NCL (non-comment line) moves subsequent embeds inside of msjsLoad()...
// export async function msjsLoad (mid) { /* module wrapper function auto-generated by the transpiler */
@js{
    // Inside msjsLoad, mid is a unique module identifier (Symbol) provided by the Mesgjs runtime upon loading.
    // fwait/fready-based feature sync doesn't work without a mid (part of active module management).
    if (!mid) throw new Error('Module MyModule requires Mesgjs module management to be active');

    // Most essential runtime functions are exposed as JS properties of `$c`, the JS presentation of the singleton `@core` Mesgjs interface instance.
    const { fready, fwait, getInstance, getInterface, setRO } = globalThis.$c;

    // To wait for dependent modules to be loaded (using their `fready` feature readiness):
    await fwait('feature1Ready', 'feature2Ready');

    // To "import" JS values from a "carrier" Mesgjs singleton interface:
    const instance = getInstance('CarrierInterface');
    // If a "carrier interface" exposes values on its Mesgjs public interface function via `setRO(d.rr, { VALUE1, value2 })`:
    const { VALUE1, value2 } = instance;

    class JSImplementationClass {
        /* ... */
    }

    // With dependencies loaded, configure *my* module interface
    const interface = getInterface('MyInterfaceName');
    interface.set({
        pristine: true, // Anti-tamper: no configuration before
        lock: true,     // ... or after
        // singleton: true,
        // abstract, chains, final, once, private, etc.
        handlers: {
        }
    });

    // To announce that e.g. a component registration service is ready to accept registrations:
    fready(mid, 'collection.registrationReady');
    /*
     * Note: Except in testMode, we can only declare ready features from our `featpro` list in the config SLID.
     * In a production environment, values in the `featpro` list we propose in the config SLID might be filtered/restricted.
     */

    // <Logic to authorize, validate, and manage registrations (and determine when expected registrations have completed)>

    // To announce that a service is ready to respond to general messages
    fready(mid, 'collection.serviceReady');
@}
// } /* end of module and auto-generated `loadMsjs` wrapper function
```

## Notes

- The JavaScript import map will generally only be sufficient to laod the Mesgjs runtime system. Except for side-loading for testing purposes with `testMode` enabled, all Mesgjs modules must be loaded via the module meta-data configuration (or via the runtime `loadModule` function in the case of modules configured for deferred loading) and using the Mesgjs-native module path resolution system. You should not attempt to use JavaScript static or dynamic imports, as these will almost certainly fail to resolve properly (at least in a production deployment).