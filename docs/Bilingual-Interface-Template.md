# Bilingual (Mesgjs And JavaScript) Interface Template

## Module Template

A Mesgjs module consists of a `.msjs` main source file and an optional `.slid` file for external SLID-format configuration (typically only required for recording module dependency information).

### The Mesgjs Source File (`.msjs`)

```javascript
[(
/*
 * This is the inline configuration SLID (static list data).
 * It contains version-immutable configuration information needed by the tranpilation and loading tools.
 */
modpath=collection/some/path/module-name
version=major.minor.patch
featreq='optional list of feature dependencies'
featpro='optional list of features provided'
modcaps='optional list of requested module capabilities'
)]

@js{
/* Outer JS embed. This code appears at the top-level of the transpiled module. This entire embed can generally be omitted. */
@}
'' // <-- This NCL (non-comment line) moves subsequent embeds inside of msjsLoad()...
// export async function msjsLoad (mid) { /* module wrapper function auto-generated by the transpiler */
@js{
    // Inside msjsLoad, mid is a unique module identifier (Symbol) provided by the Mesgjs runtime upon loading.
    // fwait/fready-based feature sync doesn't work without a mid (part of active module management).
    if (!mid) throw new Error('Module MyModule requires Mesgjs module management to be active');

    // Most essential runtime functions are exposed as JS properties of `$c`, the JS presentation of the singleton `@core` Mesgjs interface instance.
    const { fready, fwait, getInstance, getInterface, setRO, modHasCap } = globalThis.$c;

    // To wait for dependent modules to be loaded (using their `fready` feature readiness):
    await fwait('feature1Ready', 'feature2Ready');

    // To "import" JS values from a "carrier" Mesgjs singleton interface:
    const instance = getInstance('CarrierInterface');
    // If a "carrier interface" exposes values on its Mesgjs public interface function via `setRO(d.rr, { VALUE1, value2 })`:
    const { VALUE1, value2 } = instance;

    // Private, module-scoped data accessible directly to Mesgjs handlers
    const registrations = new Map();

    function registrationsAreComplete () { /* Some application logic */ }

    class JSImplementationClass {
        /* ... */
        op1 (d) {
            /* You can pass the whole dispatch object and access what you require */
        }
        op2 (fixed, named) {
            /* You can pre-process the parameters and pass what you need */
        }
        lookup (key) { // A public reader/consumer
            return registrations.get(key);
        }
        // Restricted `register` op not offered at the JS level (see below)
        // (Mesgjs sender assurances are unavailable through JS-based calls)
    }

    // If the JS implementation class should be a singleton:
    const singleton = new JSImplementationClass();

    // The `@init` handler (conventionally `opInit`) is the Mesgjs equivalent of a class constructor
    function opInit (d) {
        const instance = new JSImplementationClass(); // or singleton
        // Store the instance in the object context, d.octx
        // A common pattern, `d.octx.js` is *automatically* mirrored to `d.js`
        setRO(d.octx, 'js', instance);
        // You can make the instance available to other JS-based objects.
        // This will be externally visible as `receiver.jsv` (JavaScript value).
        setRO(d.rr, 'jsv', instance);
        // `.jsv` is a *convention* for refering to a Mesgjs-encapsulated JS value, but
        // you're not limited to `.jsv`. A "carrier" interface might want to expose more:
        setRO(d.rr, { myNum: 42, myFun: () => 'JS', myClass: JSImplementationClass });
        // const { myNum, myFun, myClass } = receiver;
    }

    // Example security options (advanced)
    // A Mesgjs message handler may act based on verified sender object instance (`d.sr`),
    // sender (interface) type (`d.st`), or sending-module identifier (a "modpath", `d.smi`).
    function opRegister (d) {
	// Works for attributed (not anonymous), inter-Mesgjs-object messages:
        if (d.st !== 'Provider') throw new Error('Only "Provider" instances may register');
	// Works with module-signed messages:
        if (!d.smi) throw new Error('Registration requests must be sent as module-signed messages');
        if (!modHasCap(d.smi, 'register')) throw new Error(`Sending module "${d.smi}" does not have permission to register`);
        const key = d.mp.at('key'), data = d.mp.at('data'), sender = d.sr;
        registrations.set(key, { sender, data });

        if (registrationsAreComplete()) {
            // Show service ready when registrations are complete
            fready(mid, 'collection.serviceReady');
        }
    }

    // With dependencies loaded, configure *my* module interface
    const interface = getInterface('MyInterfaceName');
    interface.set({
        pristine: true, // Anti-tamper: no configuration before
        lock: true,     // ... or after
        // singleton: true,
        // abstract, chains, final, once, private, etc.
        handlers: {
            '@init': opInit,
            '@jsv': d => d.js,
            lookup: d => d.js.lookup(d.mp.at('key')), // A shared JS/Mesgjs implementation
            register: opRegister, // Mesgjs-only for access control
            op1: d => d.js.op1(d),
            op2: d => d.js.op2(d.mp.at(0), d.mp.at('named')),
        }
    });

    // To announce that e.g. a component registration service is ready to accept registrations:
    fready(mid, 'collection.registrationReady');
    /*
     * Note: Except in testMode, we can only declare ready features from our `featpro` list in the config SLID.
     * In a production environment, values in the `featpro` list we propose in the config SLID might be filtered/restricted.
     */
@}
// } /* end of module and auto-generated `loadMsjs` wrapper function
```

### The Companion SLID File (`.slid`)

The companion `.slid` file is only required if the associated module has dependencies on other modules.

```
[(
modreq="modpath verspec, ...; modpath verspec, ...; ..."
)]
```

where a `verspec` is a simplified semantic-version range-specifier in one of the following forms:
- `major.minor?.patch?`: matches from the specified version up to but not including the next major version (e.g. `3.2` will match `3.2.0` up to, but not including, `4.0.0`)
- `major1.minor1?.patch1?<major2.minor2?.patch2?`: matches from `major1.minor1.patch1` up to, but not including, `major2.minor2.patch2` (e.g. `3.2<4.1` will match `3.2.0` up to, but not including, `4.1.0`)

## Notes

- The JavaScript import map will generally only be sufficient to laod the Mesgjs runtime system. Except for side-loading for testing purposes with `testMode` enabled, all Mesgjs modules must be loaded via the module meta-data configuration (or via the runtime `loadModule` function in the case of modules configured for deferred loading) and using the Mesgjs-native module path resolution system. You should not attempt to use JavaScript static or dynamic imports, as these will almost certainly fail to resolve properly (at least in a production deployment).

