import{NANOS as i,isIndex as f,isNegIndex as y}from"./vendor.esm.js";const c=t=>{const e=typeof t,n=t?.constructor?.name;return e==="object"&&t!==null&&(n===void 0||n==="Object")},d=(t,e,n={})=>{const a=typeof n?.defaultFn=="function"?n.defaultFn:()=>n.default;e=h(e,!0);for(let r of e.values()){if(t?.msjsType&&t.jsv&&(t=t.jsv),n.wrap&&(r=l(t,r)),!u(t,r))return a();if(t instanceof i)t=t.at(r,{raw:n.raw});else if(t instanceof Map)t=t.get(r);else if(c(t)||Array.isArray(t))t=t[r];else if(t instanceof Set)t=!0;else return a()}return t},u=(t,e)=>{if(t?.msjsType&&t.jsv&&(t=t.jsv),t instanceof i||t instanceof Map||t instanceof Set)return t.has(e);if(c(t)||Array.isArray(t))return Object.hasOwn(t,e)},o=t=>{if(t instanceof i)return t.next;if(Array.isArray(t))return t.length;let e;if(c(t)?e=Object.keys(t):t instanceof Map&&(e=t.keys()),e)return e.filter(f).reduce((a,r)=>Math.max(a,parseInt(r,10)),-1)+1},l=(t,e)=>{if(!y(e))return e;const n=o(t)+parseInt(e,10);return n>=0?n:void 0};class s{constructor(e){this._list=e}at(e,n){return d(this._list,e,{default:n,wrap:!0})}entries(){const e=this._list;return e instanceof i||e instanceof Map||e instanceof Set?e.entries():c(e)||Array.isArray(e)?Object.entries(e).values():[].entries()}get(e,n){return this.at(e,n)}has(e){return u(this._list,e)}*indexEntries(){for(const e of this.entries())f(e[0])&&(yield e)}*indexes(){for(const e of this.entries())f(e[0])&&(yield e[0])}*keys(){for(const e of this.entries())yield e[0]}*namedEntries(){for(const e of this.entries())f(e[0])||(yield e)}get next(){return o(this._list)}get size(){const e=this._list;return e instanceof i||e instanceof Map||e instanceof Set?e.size:[...this.entries()].length}*values(){for(const e of this.entries())f(e[0])&&(yield e[1])}}const p=new s([]);function h(t,e){return t instanceof i||t instanceof s?t:c(t)||Array.isArray(t)||t instanceof Map||t instanceof Set?new s(t):Array.isArray(t)?new s(t):typeof t=="object"&&t!==null?new s(t):e?t===void 0?p:new s([t]):t}export{c as isPlainObject,d as uniAt,u as uniHas,o as uniNext,h as unifiedList,l as wrapKey};
