import{NANOS as u,isIndex as n}from"./vendor.esm.js";const o=Symbol();class r{constructor(e){this._list=e}at(e,s){return e=this.wrapIndex(e),Object.hasOwn(this._list,e)?this._list[e]:s}get(e,s){return this.at(e,s)}has(e){return Object.hasOwn(this._list,this.wrapIndex(e))}*indexEntries(){for(const e of this.entries())n(e[0])&&(yield e)}*indexes(){for(const e of this.keys())n(e)&&(yield e)}get size(){return this._size===void 0&&(this._size=Object.keys(this._list).length),this._size}wrapIndex(e){return/^-[1-9]\d*$/.test(e)&&(e=parseInt(e)+this.next,e<0)?o:e}}class i extends r{*entries(){for(const e of this.keys())yield[e,this._list[e]]}indexEntries(){return this._list.entries()}keys(){return Object.keys(this._list).values()}get next(){return this._list.length}values(){return this._list.values()}}class h extends r{entries(){return Object.entries(this._list).values()}keys(){return Object.keys(this._list).values()}get next(){return this._next===void 0&&(this._next=this.indexes().reduce((e,s)=>Math.max(e,s),-1)+1),this._next}*values(){for(let e=0;e<this.next;++e)yield this.at(e)}}const f=new i([]);function d(t,e){for(const s of[u,i,h])if(t instanceof s)return t;return Array.isArray(t)?new i(t):typeof t=="object"&&t!==null?new h(t):e?t===void 0?f:new i([t]):t}export{d as unifiedList};
