{
  "version": 3,
  "sources": ["../../src/runtime/unified-list.esm.js"],
  "sourcesContent": ["/*\n * Mesgjs Unified List Interface\n *\n * A minimalist universal interface to support passing JS arrays, plain\n * objects, and other native JS values as message parameter lists with\n * consistent semantics. NANOS is the reference interface.\n *\n * Copyright 2025 by Kappa Computer Solutions, LLC and Brian Katzung\n * Author: Brian Katzung <briank@kappacs.com>\n */\n\nimport { NANOS, isIndex, isNegIndex } from './vendor.esm.js';\n\nexport const isPlainObject = (obj) => {\n    const type = typeof obj, consName = obj?.constructor?.name;\n    return (type === 'object' && obj !== null && (consName === undefined || consName === 'Object'));\n};\n\n/**\n * Traverse mixed-type object structures.\n * @param {object} [opts] Options\n * @param {*} [opts.default] Default return value if next key is not present\n * @param {*} [opts.defaultFn] Default return-value function if next key is not present\n * @param {boolean} [opts.wrap] Wrap around negative index keys\n */\nexport const uniAt = (obj, keyPath, opts = {}) => {\n    const defFn = (typeof opts?.defaultFn === 'function') ? opts.defaultFn : (() => opts.default);\n    keyPath = unifiedList(keyPath, true);\n    for (let key of keyPath.values()) {\n        if (obj?.msjsType && obj.jsv) obj = obj.jsv;\n\tif (opts.wrap) key = wrapKey(obj, key);\n\tif (!uniHas(obj, key)) return defFn();\n\tif (obj instanceof NANOS || obj instanceof Map) obj = obj.get(key);\n\telse if (isPlainObject(obj) || Array.isArray(obj)) obj = obj[key];\n\telse if (obj instanceof Set) obj = true;\n\telse return defFn();\n    }\n    return obj;\n};\n\n// Does the object have the specified key?\nexport const uniHas = (obj, key) => {\n    if (obj?.msjsType && obj.jsv) obj = obj.jsv;\n    if (obj instanceof NANOS || obj instanceof Map || obj instanceof Set) return obj.has(key);\n    if (isPlainObject(obj) || Array.isArray(obj)) return Object.hasOwn(obj, key);\n    // Unknown/undefined for unsupported types\n};\n\n// Return the next-index for map-ish values\nexport const uniNext = (obj) => {\n    if (obj instanceof NANOS) return obj.next;\n    if (Array.isArray(obj)) return obj.length;\n    let keys;\n    if (isPlainObject(obj)) keys = Object.keys(obj);\n    else if (obj instanceof Map) keys = obj.keys();\n    if (keys) {\n\tconst next = keys.filter(isIndex).reduce((acc, cur) => Math.max(acc, parseInt(cur, 10)), -1) + 1;\n\treturn next;\n    }\n};\n\n// Wrap negative index keys relative to the object's \"next\"\nexport const wrapKey = (obj, key) => {\n    if (!isNegIndex(key)) return key;\n    const newKey = uniNext(obj) + parseInt(key, 10);\n    return ((newKey >= 0) ? newKey : undefined);\n};\n\nclass ListProxy {\n    constructor (list) {\n\tthis._list = list;\n    }\n\n    // Get value for key\n    at (key, def) {\n\treturn uniAt(this._list, key, { default: def, wrap: true });\n    }\n\n    // Iterates over all the key/value entries\n    entries () {\n\tconst list = this._list;\n\tif (list instanceof NANOS || list instanceof Map || list instanceof Set) return list.entries();\n\tif (isPlainObject(list) || Array.isArray(list)) return Object.entries(list).values();\n\treturn [].entries();\n    }\n\n    // Alias for at\n    get (key, def) { return this.at(key, def); }\n\n    // Return with a key is present\n    has (key) { return uniHas(this._list, key); }\n\n    // Iterates over index entries\n    *indexEntries () {\n\tfor (const kv of this.entries()) if (isIndex(kv[0])) yield kv;\n    }\n\n    // Iterates over index keys\n    *indexes () {\n\tfor (const kv of this.entries()) if (isIndex(kv[0])) yield kv[0];\n    }\n\n    // Iterates over all keys\n    *keys () {\n\tfor (const kv of this.entries()) yield kv[0];\n    }\n\n    // Iterates over named entries\n    *namedEntries () {\n\tfor (const kv of this.entries()) if (!isIndex(kv[0])) yield kv;\n    }\n\n    // Return the next-index key\n    get next () {\n\treturn uniNext(this._list);\n    }\n\n    // Return the size of the list (= # of keys)\n    get size () {\n\tconst list = this._list;\n\tif (list instanceof NANOS || list instanceof Map || list instanceof Set) return list.size;\n\treturn [...this.entries()].length;\n    }\n\n    // Iterate over *positional* values\n    *values () {\n\tfor (const kv of this.entries()) if (isIndex(kv[0])) yield kv[1];\n    }\n}\n\nconst emptyList = new ListProxy([]);\n\nexport function unifiedList (value, promote) {\n    if (value instanceof NANOS || value instanceof ListProxy) return value;\n    if (isPlainObject(value) || Array.isArray(value) || value instanceof Map || value instanceof Set) return new ListProxy(value);\n    if (Array.isArray(value)) return new ListProxy(value);\n    if (typeof value === 'object' && value !== null) return new ListProxy(value);\n    if (!promote) return value;\n    if (value === undefined) return emptyList;\n    return new ListProxy([ value ]);\n}\n\n// END\n"],
  "mappings": "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",
  "names": ["NANOS", "isIndex", "isNegIndex", "isPlainObject", "obj", "type", "consName", "uniAt", "keyPath", "opts", "defFn", "unifiedList", "key", "wrapKey", "uniHas", "uniNext", "keys", "acc", "cur", "newKey", "ListProxy", "list", "def", "kv", "emptyList", "value", "promote"]
}
