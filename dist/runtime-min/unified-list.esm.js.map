{
  "version": 3,
  "sources": ["../../src/runtime/unified-list.esm.js"],
  "sourcesContent": ["/*\n * Mesgjs Unified List Interface\n *\n * A minimalist universal interface to support passing JS arrays, plain\n * objects, and other native JS values as message parameter lists with\n * consistent semantics. NANOS is the reference interface.\n *\n * Copyright 2025 by Kappa Computer Solutions, LLC and Brian Katzung\n * Author: Brian Katzung <briank@kappacs.com>\n */\n\nimport { NANOS, isIndex, isNegIndex } from './vendor.esm.js';\n\nexport const isPlainObject = (obj) => {\n\tconst type = typeof obj, consName = obj?.constructor?.name;\n\treturn (type === 'object' && obj !== null && (consName === undefined || consName === 'Object'));\n};\n\n/**\n * Traverse mixed-type object structures.\n * @param {object} [opts] Options\n * @param {*} [opts.default] Default return value if next key is not present\n * @param {*} [opts.defaultFn] Default return-value function if next key is not present\n * @param {boolean} [opts.wrap] Wrap around negative index keys\n */\nexport const uniAt = (obj, keyPath, opts = {}) => {\n\tconst defFn = (typeof opts?.defaultFn === 'function') ? opts.defaultFn : (() => opts.default);\n\tkeyPath = unifiedList(keyPath, true);\n\tfor (let key of keyPath.values()) {\n\t\tif (obj?.msjsType && obj.jsv) obj = obj.jsv;\n\t\tif (opts.wrap) key = wrapKey(obj, key);\n\t\tif (!uniHas(obj, key)) return defFn();\n\t\tif (obj instanceof NANOS) obj = obj.at(key, { raw: opts.raw });\n\t\telse if (obj instanceof Map) obj = obj.get(key);\n\t\telse if (isPlainObject(obj) || Array.isArray(obj)) obj = obj[key];\n\t\telse if (obj instanceof Set) obj = true;\n\t\telse return defFn();\n\t}\n\treturn obj;\n};\n\n// Does the object have the specified key?\nexport const uniHas = (obj, key) => {\n\tif (obj?.msjsType && obj.jsv) obj = obj.jsv;\n\tif (obj instanceof NANOS || obj instanceof Map || obj instanceof Set) return obj.has(key);\n\tif (isPlainObject(obj) || Array.isArray(obj)) return Object.hasOwn(obj, key);\n\t// Unknown/undefined for unsupported types\n};\n\n// Return the next-index for map-ish values\nexport const uniNext = (obj) => {\n\tif (obj instanceof NANOS) return obj.next;\n\tif (Array.isArray(obj)) return obj.length;\n\tlet keys;\n\tif (isPlainObject(obj)) keys = Object.keys(obj);\n\telse if (obj instanceof Map) keys = obj.keys();\n\tif (keys) {\n\t\tconst next = keys.filter(isIndex).reduce((acc, cur) => Math.max(acc, parseInt(cur, 10)), -1) + 1;\n\t\treturn next;\n\t}\n};\n\n// Wrap negative index keys relative to the object's \"next\"\nexport const wrapKey = (obj, key) => {\n\tif (!isNegIndex(key)) return key;\n\tconst newKey = uniNext(obj) + parseInt(key, 10);\n\treturn ((newKey >= 0) ? newKey : undefined);\n};\n\nclass ListProxy {\n\tconstructor (list) {\n\t\tthis._list = list;\n\t}\n\n\t// Get value for key\n\tat (key, def) {\n\t\treturn uniAt(this._list, key, { default: def, wrap: true });\n\t}\n\n\t// Iterates over all the key/value entries\n\tentries () {\n\t\tconst list = this._list;\n\t\tif (list instanceof NANOS || list instanceof Map || list instanceof Set) return list.entries();\n\t\tif (isPlainObject(list) || Array.isArray(list)) return Object.entries(list).values();\n\t\treturn [].entries();\n\t}\n\n\t// Alias for at\n\tget (key, def) { return this.at(key, def); }\n\n\t// Return with a key is present\n\thas (key) { return uniHas(this._list, key); }\n\n\t// Iterates over index entries\n\t*indexEntries () {\n\t\tfor (const kv of this.entries()) if (isIndex(kv[0])) yield kv;\n\t}\n\n\t// Iterates over index keys\n\t*indexes () {\n\t\tfor (const kv of this.entries()) if (isIndex(kv[0])) yield kv[0];\n\t}\n\n\t// Iterates over all keys\n\t*keys () {\n\t\tfor (const kv of this.entries()) yield kv[0];\n\t}\n\n\t// Iterates over named entries\n\t*namedEntries () {\n\t\tfor (const kv of this.entries()) if (!isIndex(kv[0])) yield kv;\n\t}\n\n\t// Return the next-index key\n\tget next () {\n\t\treturn uniNext(this._list);\n\t}\n\n\t// Return the size of the list (= # of keys)\n\tget size () {\n\t\tconst list = this._list;\n\t\tif (list instanceof NANOS || list instanceof Map || list instanceof Set) return list.size;\n\t\treturn [...this.entries()].length;\n\t}\n\n\t// Iterate over *positional* values\n\t*values () {\n\t\tfor (const kv of this.entries()) if (isIndex(kv[0])) yield kv[1];\n\t}\n}\n\nconst emptyList = new ListProxy([]);\n\nexport function unifiedList (value, promote) {\n\tif (value instanceof NANOS || value instanceof ListProxy) return value;\n\tif (isPlainObject(value) || Array.isArray(value) || value instanceof Map || value instanceof Set) return new ListProxy(value);\n\tif (Array.isArray(value)) return new ListProxy(value);\n\tif (typeof value === 'object' && value !== null) return new ListProxy(value);\n\tif (!promote) return value;\n\tif (value === undefined) return emptyList;\n\treturn new ListProxy([ value ]);\n}\n\n// END\n"],
  "mappings": "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",
  "names": ["NANOS", "isIndex", "isNegIndex", "isPlainObject", "obj", "type", "consName", "uniAt", "keyPath", "opts", "defFn", "unifiedList", "key", "wrapKey", "uniHas", "uniNext", "keys", "acc", "cur", "newKey", "ListProxy", "list", "def", "kv", "emptyList", "value", "promote"]
}
