import{getInterface as y,runIfCode as w,setRO as R,throwFlow as d}from"./runtime.esm.js";import{NANOS as j}from"./vendor.esm.js";function v(a){const{mp:e,js:t}=a,n=parseInt(e.at("times",1),10),p=Number.isInteger(n)?n:1,c=e.at("collect");let o=c?new j:void 0;const l=r=>{c?o.push(r):o=r};t.times=p,t.active=!0;try{for(let r=0;r<p;++r){t.capture=!1,t.iteration=r;try{l(w(e.at(0)))}catch(f){if(!t.capture)throw f;if(t.hasFlowRes&&(l(t.flowRes),t.hasFlowRes=t.flowRes=!1),f.message==="stop")break}}}finally{t.active=!1}return o}function b(a){const{mp:e,js:t}=a,n=s=>s?.msjsType==="@code"?s:void 0,p=e.at(0),c=n(e.at(1)),o=n(e.at("pre")),l=c&&n(e.at("mid")),r=n(e.at("post"));if(!o&&!l&&!r)throw new SyntaxError("(while) test {block!} required");const f=e.at("collect");let m=f?new j:void 0;const h=s=>{f?m.push(s):m=s},u=s=>{if(!t.capture||(t.hasFlowRes&&(h(t.flowRes),t.hasFlowRes=t.flowRes=!1),s.message==="stop"))throw s;t.capture=!1};t.times=void 0,t.active=!0;try{for(let s=0;;++s){t.capture=!1,t.iteration=s;try{try{if(o&&!o("run"))break}catch(i){u(i)}try{h(w(p))}catch(i){u(i)}if(c){try{if(l&&!l("run"))break}catch(i){u(i)}try{c("run")}catch(i){u(i)}}try{if(r&&!r("run"))break}catch(i){u(i)}}catch(i){if(t.active=!1,!t.capture)throw i;if(i.message==="stop")break;t.active=!0}}}finally{t.active=!1}return m}function g(a){y(a).set({lock:!0,pristine:!0,handlers:{"@init":e=>R(e.octx,"js",{}),active:e=>!!e.js.active,num:e=>e.js.iteration,num1:e=>e.js.iteration+1,next:e=>d(e,"next",a),rem:e=>e.js.times?e.js.times-e.js.iteration-1:void 0,rem1:e=>e.js.times?e.js.times-e.js.iteration:void 0,run:v,stop:e=>d(e,"stop",a),times:e=>e.js.times,while:b},cacheHints:{while:"pin"}})}export{g as install};
