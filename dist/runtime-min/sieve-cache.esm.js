class a{constructor(t,s){this.key=t,this.value=s,this.ref=!1,this.next=null}}class n{constructor(t=256){this.capacity=t,this.map=new Map,this.hand=null,this.size=0}clear(){this.map.clear(),this.hand=null,this.size=0}_evictAndInsert(t){let s=0;for(;s<this.capacity;){const e=this.hand.next;if(e.ref)e.ref=!1,this.hand=e,s++;else{this.map.delete(e.key),t.next=e.next,this.hand.next=t;return}}const i=this.hand.next;this.map.delete(i.key),t.next=i.next,this.hand.next=t}get(t){const s=this.map.get(t);if(s)return s.ref=!0,s.value}has(t){return this.map.has(t)}_insert(t){this.hand?(t.next=this.hand.next,this.hand.next=t):(t.next=t,this.hand=t)}keys(){return this.map.keys()}set(t,s,i=!1){let e=this.map.get(t);if(e){e.value=s,e.ref=!0;return}e=new a(t,s),i||(this.size<this.capacity?(this._insert(e),this.size++):this._evictAndInsert(e)),this.map.set(t,e)}}export{n as SieveCache,a as SieveEntry,n as default};
