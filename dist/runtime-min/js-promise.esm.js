import{getInstance as j,getInterface as v,setRO as d}from"./runtime.esm.js";import{NANOS as w}from"./vendor.esm.js";const A=e=>e,b=e=>{throw e},y=e=>typeof e=="function"&&(!e.msjsType||e.msjsType==="@code"||e.msjsType==="@function"),E=e=>typeof e?.then=="function",s=Symbol(),m=e=>Object.assign(new w(e),e);function c(e){if(Array.isArray(e))return e;if(typeof e?.[Symbol.iterator]=="function"||typeof e?.next=="function")return Array.from(e);if(typeof e?.values=="function")return[...e.values()]}function f(e){const{state:t,result:r}=this[s],n=t==="fulfilled";if(!n&&!e.length){queueMicrotask(()=>Promise.reject(r));return}for(const a of e){const[i,l,h]=a;queueMicrotask(()=>{try{const o=n?i:l,p=o.msjsType;if(p){const g=n?{state:t,resolve:r}:{state:t,reject:r,message:r?.message};h.resolve(o(p==="@code"?"run":"call",g))}else h.resolve(o(r))}catch(o){h.reject(o)}})}}const u=Object.setPrototypeOf({all(e){if(this[s].state!=="pending")return;if(e=c(e),!Array.isArray(e))throw new TypeError("@promise(all) requires an iterable of promises");const t=[];let r=e.length;return r||this.resolve(t),e.forEach((n,a)=>{n.then(i=>{t[a]=i,--r===0&&this.resolve(t)},i=>this.reject(i))}),this},allSettled(e){if(this[s].state!=="pending")return;if(e=c(e),!Array.isArray(e))throw new TypeError("@promise(allSettled) requires an iterable of promises");const t=[];let r=e.length;return r||this.resolve(t),e.forEach((n,a)=>{n.then(i=>{t[a]=m({status:"fulfilled",value:i}),--r===0&&this.resolve(t)},i=>{t[a]=m({status:"rejected",reason:i}),--r===0&&this.resolve(t)})}),this},always(e){return this.then(e,e)},any(e){if(this[s].state!=="pending")return;if(e=c(e),!Array.isArray(e))throw new TypeError("@promise(any) requires an iterable of promises");const t=[];let r=e.length;const n=()=>this.reject(new AggregateError(t,"All promises were rejected"));return r||n(),e.forEach((a,i)=>{a.then(l=>this.resolve(l),l=>{t[i]=l,--r===0&&n()})}),this},cancel(){const e=this[s];e.timerId&&(clearTimeout(e.timerId),e.timerId=void 0)},catch(e){return this.then(null,e)},get jsv(){return this},then(e,t){const r=this[s];y(e)||(e=A),y(t)||(t=b);const n=[e,t,j("@promise")];return r.handlers?r.handlers.push(n):queueMicrotask(()=>f.call(this,[n])),n[2]},race(e){if(this[s].state==="pending"){if(e=c(e),!Array.isArray(e))throw new TypeError("@promise(race) requires an iterable of promises");return e.length||console.warn("@promise empty (race) will never settle!"),e.forEach(t=>t.then(r=>this.resolve(r),r=>this.reject(r))),this}},reject(e){const t=this[s];t.state==="pending"&&(t.state="rejected",e instanceof Error||(e=new Error(e)),t.result=e,queueMicrotask(()=>{f.call(this,t.handlers),t.handlers=null}))},resolve(e){const t=this[s];if(t.state==="pending"){if(E(e)){e.then(r=>this.resolve(r),r=>this.reject(r));return}t.state="fulfilled",t.result=e,queueMicrotask(()=>{f.call(this,t.handlers),t.handlers=null})}},get result(){return this[s].result},get state(){return this[s].state},valueOf(){return this},wait(e,t){const r=this[s];if(r.state!=="pending")return;const n=()=>{t?.msjsType==="@code"?this.resolve(t("run")):typeof t=="function"?this.resolve(t()):this.resolve(t)};return this.cancel(),r.timerId=setTimeout(n,e),this}},Function.prototype);u.finally=u.always;function T(e){Object.setPrototypeOf(e.rr,u),d(e.rr,s,{state:"pending",result:void 0,handlers:[],timerId:void 0}),e.mp.has("resolve")&&e.rr.resolve(e.mp.at("resolve")),e.mp.has("reject")&&e.rr.reject(e.mp.at("reject"))}function O(e){v(e).set({lock:!0,pristine:!0,handlers:{"@init":T,"@jsv":t=>t.rr,all:t=>t.rr.all(t.mp),allSettled:t=>t.rr.allSettled(t.mp),always:t=>t.rr.always(t.mp.at(0)),any:t=>t.rr.any(t.mp),cancel:t=>t.rr.cancel(),catch:t=>t.rr.catch(t.mp.at(0)),message:t=>t.rr.result?.message,race:t=>t.rr.race(t.mp),reject:t=>t.rr.reject(t.mp.at(0)),resolve:t=>t.rr.resolve(t.mp.at(0)),result:t=>t.rr.result,state:t=>t.rr.state,then:t=>t.rr.then(t.mp.at(0),t.mp.at(1)),wait:t=>t.rr.wait(t.mp.at(0),t.mp.at(1))}})}export{O as install};
