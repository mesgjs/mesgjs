import{getInterface as g,runIfCode as l,setRO as w,throwFlow as m,typeAccepts as o}from"./runtime.esm.js";import{isIndex as A,NANOS as R}from"./vendor.esm.js";function x(e,s){const{mp:i,js:t}=e,f=i.at("collect"),r=t.src.get;let u=f?new R:void 0,v=0;const a=n=>{f?u.push(n):u=n},y=n=>{if(!t.capture||(t.hasFlowRes&&(a(t.flowRes),t.hasFlowRes=t.flowRes=!1),n.message==="stop"))throw n;t.capture=!1},p=i.at("index"),k=i.at("named"),d=p||k,h=i.at(1);t.active=!0;try{for(const n of s){if(t.capture=!1,++v,[t.key,t.value]=[n,r(n)],d)if(A(n)){t.isIndex=!0;try{p&&a(l(p))}catch(c){y(c)}}else{t.isIndex=!1;try{k&&a(l(k))}catch(c){y(c)}}try{h&&a(l(h))}catch(c){y(c)}}t.active=!1}catch(n){if(!t.capture)throw n}finally{t.active=!1}if(!v){const n=e.mp.at("else");if(n)return l(n)}return u}function I(e){const s=typeof e,i=e?.msjsType;let t,f;return(s!=="object"&&s!=="function"||e===null)&&(e=[e]),i?(o(i,"keyIter")?t=e("keyIter"):o(i,"keys")&&(t=e("keys").values()),o(i,"at")?f=r=>e("at",[r]):o(i,"get")&&(f=r=>e("get",[r]))):(typeof e?.keys=="function"?(t=e.keys(),Array.isArray(t)&&(t=t.values())):Array.isArray(e?.keys)&&(t=e.keys.values()),typeof e?.at=="function"?f=r=>e.at(r):typeof e?.get=="function"?f=r=>e.get(r):f=r=>e[r]),t||=[].values(),f||=()=>{},{keys:t,get:f}}function F(e){const s=e.js.src=I(e.mp.at(0));return x(e,s.keys)}function N(e){const s=e.js.src=I(e.mp.at(0));return x(e,[...s.keys].reverse())}function C(e){g(e).set({lock:!0,pristine:!0,handlers:{"@init":s=>w(s.octx,"js",{}),active:s=>!!s.js.active,for:F,isIndex:s=>s.js.isIndex,key:s=>s.js.key,next:s=>m(s,"next",e),rev:N,stop:s=>m(s,"stop",e),value:s=>s.js.value}})}export{C as install};
