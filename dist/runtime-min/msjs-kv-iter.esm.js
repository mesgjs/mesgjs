import{getInterface as g,runIfCode as l,setRO as w,throwFlow as h,typeAccepts as o}from"./runtime.esm.js";import{isIndex as A,NANOS as R}from"./vendor.esm.js";import{unifiedList as F}from"./unified-list.esm.js";function d(e,s){const{mp:r,js:t}=e,f=r.at("collect"),n=t.src.get;let u=f?new R:void 0,v=0;const a=i=>{f?u.push(i):u=i},y=i=>{if(!t.capture||(t.hasFlowRes&&(a(t.flowRes),t.hasFlowRes=t.flowRes=!1),i.message==="stop"))throw i;t.capture=!1},p=r.at("index"),k=r.at("named"),I=p||k,m=r.at(1);t.active=!0;try{for(const i of s){if(t.capture=!1,++v,[t.key,t.value]=[i,n(i)],I)if(A(i)){t.isIndex=!0;try{p&&a(l(p))}catch(c){y(c)}}else{t.isIndex=!1;try{k&&a(l(k))}catch(c){y(c)}}try{m&&a(l(m))}catch(c){y(c)}}t.active=!1}catch(i){if(!t.capture)throw i}finally{t.active=!1}if(!v){const i=e.mp.at("else");if(i)return l(i)}return u}function x(e){const s=typeof e,r=e?.msjsType;let t,f;return(s!=="object"&&s!=="function"||e===null)&&(e=[e]),r?(o(r,"keyIter")?t=e("keyIter"):o(r,"keys")&&(t=e("keys").values()),o(r,"at")?f=n=>e("at",[n]):o(r,"get")&&(f=n=>e("get",[n]))):(e=F(e),typeof e?.keys=="function"?(t=e.keys(),Array.isArray(t)&&(t=t.values())):Array.isArray(e?.keys)&&(t=e.keys.values()),typeof e?.at=="function"?f=n=>e.at(n):typeof e?.get=="function"?f=n=>e.get(n):f=n=>e[n]),t||=[].values(),f||=()=>{},{keys:t,get:f}}function N(e){const s=e.js.src=x(e.mp.at(0));return d(e,s.keys)}function O(e){const s=e.js.src=x(e.mp.at(0));return d(e,[...s.keys].reverse())}function L(e){g(e).set({lock:!0,pristine:!0,handlers:{"@init":s=>w(s.octx,"js",{}),active:s=>!!s.js.active,for:N,isIndex:s=>s.js.isIndex,key:s=>s.js.key,next:s=>h(s,"next",e),rev:O,stop:s=>h(s,"stop",e),value:s=>s.js.value}})}export{L as install};
