import{getInterface as R,runIfCode as c,setRO as F,throwFlow as w,typeAccepts as h}from"./runtime.esm.js";import{isIndex as x,NANOS as N}from"./vendor.esm.js";import{unifiedList as O}from"./unified-list.esm.js";function I(e,s){const{mp:f,js:t}=e,n=f.at("collect"),i=t.src.get;let p=n?new N:void 0,v=0;const o=r=>{n?p.push(r):p=r},l=r=>{if(!t.capture||(t.hasFlowRes&&(o(t.flowRes),t.hasFlowRes=t.flowRes=!1),r.message==="stop"))throw r;t.capture=!1},u=f.at("index"),y=f.at("named"),m=u||y,k=f.at(1);t.active=!0;try{if(e.dop==="afor"||e.dop==="arev")return(async()=>{for(const r of s){if(t.capture=!1,++v,[t.key,t.value]=[r,i(r)],m)if(x(r)){t.isIndex=!0;try{u&&o(await c(u))}catch(a){l(a)}}else{t.isIndex=!1;try{y&&o(await c(y))}catch(a){l(a)}}try{k&&o(await c(k))}catch(a){l(a)}}if(!v){const r=e.mp.at("else");if(r)return await c(r)}return p})();for(const r of s){if(t.capture=!1,++v,[t.key,t.value]=[r,i(r)],m)if(x(r)){t.isIndex=!0;try{u&&o(c(u))}catch(a){l(a)}}else{t.isIndex=!1;try{y&&o(c(y))}catch(a){l(a)}}try{k&&o(c(k))}catch(a){l(a)}}if(!v){const r=e.mp.at("else");if(r)return c(r)}return p}catch(r){if(!t.capture)throw r}finally{t.active=!1}}function d(e){const s=typeof e,f=e?.msjsType;let t,n;return(s!=="object"&&s!=="function"||e===null)&&(e=[e]),f?(h(f,"keyIter")?t=e("keyIter"):h(f,"keys")&&(t=e("keys").values()),h(f,"at")?n=i=>e("at",[i]):h(f,"get")&&(n=i=>e("get",[i]))):(e=O(e),typeof e?.keys=="function"?(t=e.keys(),Array.isArray(t)&&(t=t.values())):Array.isArray(e?.keys)&&(t=e.keys.values()),typeof e?.at=="function"?n=i=>e.at(i):typeof e?.get=="function"?n=i=>e.get(i):n=i=>e[i]),t||=[].values(),n||=()=>{},{keys:t,get:n}}function g(e){const s=e.js.src=d(e.mp.at(0));return I(e,s.keys)}function A(e){const s=e.js.src=d(e.mp.at(0));return I(e,[...s.keys].reverse())}function L(e){R(e).set({lock:!0,pristine:!0,handlers:{"@init":s=>F(s.octx,"js",{}),active:s=>!!s.js.active,afor:g,arev:A,for:g,isIndex:s=>s.js.isIndex,key:s=>s.js.key,next:s=>w(s,"next",e),rev:A,stop:s=>w(s,"stop",e),value:s=>s.js.value}})}export{L as install};
