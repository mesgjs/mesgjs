import{getInstance as h,getInterface as j,runIfCode as l,setRO as m}from"./runtime.esm.js";import{unifiedList as c,uniAt as N}from"./unified-list.esm.js";function y(e){const{octx:t,mp:n}=e,s=n.at(0);m(t,"js",s instanceof NANOS?s:new NANOS)}function p(e){const{mp:t}=e,n=t.has("path")?c(t.at("path")).values():t.values();return N(e.js,[...n],{wrap:!0,raw:t.at("raw"),defaultFn:()=>{if(t.has("else"))return l(t.at("else"));throw new Error("Key path not found")}})}function k(){if(this.list.has(this.key))return this.list.at(this.key);if(this.hasElse)return l(this.elseVal);throw new Error(`Required key ${this.key} not present`)}function S(e){const{js:t,mp:n}=e,s=n.at(0),a=n.has("else"),i=n.at("else");return e.b({cd:k.bind({list:t,key:s,hasElse:a,elseVal:i})})}function O(e){return e.mp.has(0)?(e.js.next=e.mp.at(0),e.rr):e.js.next}function u(e){const{mp:t,js:n}=e;for(const s of t.entries())n.set(s[0],s[1])}function w(e){const{js:t,mp:n}=e;if(n.has(0)){let s=n.at(0);return s===!0&&(s=h("@reactive")("rio")),t.rio=s,e.rr}return!!t.rio}function A(e){this.list.set(this.key,e.mp.at(0),{raw:e.mp.at("raw")})}function x(e){const{js:t,mp:n}=e,s=n.at(0);return e.b({cd:A.bind({list:t,key:s})})("fn")}const v=e=>{const t=typeof e;return t==="string"||t==="number"||t==="symbol"};function f(e){const{mp:t}=e,s=[...t.has("path")?c(t.at("path")).values():t.values()].filter(r=>v(r)),a=s.length-(t.has("to")?1:0);let i=e.js;for(let r=0;r<a;++r){const o=s[r];i.at(o)instanceof NANOS||i.set(o,i.similar()),i=i.at(o)}t.has("to")?i.set(s[a],t.at("to"),t.at("insert")):(t.has("first")&&i.unshift(t.at("first")),t.has("next")&&i.push(t.at("next")))}function K(e){j(e).set({lock:!0,pristine:!0,handlers:{"@init":y,"@jsv":t=>t.js,"@":p,"==":u,">":t=>t.js.pop(),"|+":t=>t.js.push(t.mp),"=":f,"<":t=>t.js.shift(),"+|":t=>t.js.unshift(t.mp),at:p,clear:t=>t.js.clear(),copy:t=>new NANOS().fromPairs(t.js.pairs()),delete:t=>t.js.delete(t.mp.at(0)),depend:t=>t.js.depend(),entries:t=>new NANOS([...t.js.entries()]),get:p,getter:S,has:t=>t.js.has(t.mp.at(0)),includes:t=>t.js.includes(t.mp.at(0)),indexEntries:t=>new NANOS([...t.js.indexEntries(t.mp.at(0))]),indexKeys:t=>new NANOS([...t.js.indexKeys()]),isLocked:t=>t.js.isLocked(t.mp.at(0)),isRedacted:t=>t.js.isRedacted(t.mp.at(0)),keyOf:t=>t.js.keyOf(t.mp.at(0)),keyIter:t=>t.js.keys(),keys:t=>new NANOS([...t.js.keys()]),lastKeyOf:t=>t.js.lastKeyOf(t.mp.at(0)),lock:t=>t.js.lock(...t.mp.indexValues()),lockAll:t=>t.js.lockAll(t.mp.at(0)),lockKeys:t=>t.js.lockKeys(),namedEntries:t=>new NANOS([...t.js.namedEntries()]),namedKeys:t=>new NANOS([...t.js.namedKeys()]),next:O,nset:u,pairs:t=>new NANOS(t.js.pairs(t.mp.at(0))),pop:t=>t.js.pop(),push:t=>t.js.push(t.mp),push1:t=>t.js.push(t.mp.at(0)),redact:t=>t.js.redact(...t.mp.indexValues()),reverse:t=>t.js.reverse(),rio:w,self:t=>t.js,set:f,setter:x,shift:t=>t.js.shift(),size:t=>t.js.size,toJSON:t=>t.js.toJSON(),toReversed:t=>t.js.toReversed(),toSLID:t=>t.js.toSLID(t.mp?.storage||{}),toString:t=>t.js.toString(t.mp?.storage||{}),unshift:t=>t.js.unshift(t.mp),values:t=>new NANOS([...t.js.values()])},cacheHints:{"@init":"pin",at:"pin",has:"pin",nset:"pin",set:"pin"}})}export{K as install};
