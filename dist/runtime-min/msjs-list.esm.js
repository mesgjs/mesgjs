import{getInstance as j,getInterface as m,runIfCode as c,setRO as f}from"./runtime.esm.js";import{unifiedList as p}from"./unified-list.esm.js";function N(t){const{octx:s,mp:n}=t,e=n.at(0);f(s,"js",e instanceof NANOS?e:new NANOS),f(t.js,$c.symbols.instance,t.rr,!1)}function l(t){const{mp:s}=t,n=s.has("path")?p(s.at("path")).values():s.values();let e=t.js;for(const r of n)if(e.has(r))e=p(e.at(r));else{if(s.has("else"))return c(s.at("else"));throw new Error("Key path not found")}return e}function y(){if(this.list.has(this.key))return this.list.at(this.key);if(this.hasElse)return c(this.elseVal);throw new Error(`Required key ${this.key} not present`)}function k(t){const{js:s,mp:n}=t,e=n.at(0),r=n.has("else"),i=n.at("else");return t.b({cd:y.bind({list:s,key:e,hasElse:r,elseVal:i})})}function S(t){return t.mp.has(0)?(t.js.next=t.mp.at(0),t.rr):t.js.next}function u(t){const{mp:s,js:n}=t;for(const e of s.entries())n.set(e[0],e[1])}function O(t){const{js:s,mp:n}=t;if(n.has(0)){let e=n.at(0);return e===!0&&(e=j("@reactive")("rio")),s.rio=e,t.rr}return!!s.rio}function A(t){this.list.set(this.key,t.mp.at(0))}function w(t){const{js:s,mp:n}=t,e=n.at(0);return t.b({cd:A.bind({list:s,key:e})})("fn")}const x=t=>{const s=typeof t;return s==="string"||s==="number"||s==="symbol"};function h(t){const{mp:s}=t,e=[...s.has("path")?p(s.at("path")).values():s.values()].filter(a=>x(a)),r=e.length-(s.has("to")?1:0);let i=t.js;for(let a=0;a<r;++a){const o=e[a];i.at(o)instanceof NANOS||i.set(o,i.similar()),i=i.at(o)}s.has("to")?i.set(e[r],s.at("to"),s.at("insert")):(s.has("first")&&i.unshift(s.at("first")),s.has("next")&&i.push(s.at("next")))}function d(t){m(t).set({lock:!0,pristine:!0,handlers:{"@init":N,"@jsv":s=>s.js,"@":l,"==":u,">":s=>s.js.pop(),"|+":s=>s.js.push(s.mp),"=":h,"<":s=>s.js.shift(),"+|":s=>s.js.unshift(s.mp),at:l,clear:s=>s.js.clear(),copy:s=>new NANOS().fromPairs(s.js.pairs()),delete:s=>s.js.delete(s.mp.at(0)),depend:s=>s.js.depend(),entries:s=>new NANOS([...s.js.entries()]),get:l,getter:k,has:s=>s.js.has(s.mp.at(0)),includes:s=>s.js.includes(s.mp.at(0)),indexEntries:s=>new NANOS([...s.js.indexEntries(s.mp.at(0))]),indexKeys:s=>new NANOS([...s.js.indexKeys()]),isLocked:s=>s.js.isLocked(s.mp.at(0)),isRedacted:s=>s.js.isRedacted(s.mp.at(0)),keyOf:s=>s.js.keyOf(s.mp.at(0)),keyIter:s=>s.js.keys(),keys:s=>new NANOS([...s.js.keys()]),lastKeyOf:s=>s.js.lastKeyOf(s.mp.at(0)),lock:s=>s.js.lock(...s.mp.indexValues()),lockAll:s=>s.js.lockAll(s.mp.at(0)),lockKeys:s=>s.js.lockKeys(),namedEntries:s=>new NANOS([...s.js.namedEntries()]),namedKeys:s=>new NANOS([...s.js.namedKeys()]),next:S,nset:u,pairs:s=>new NANOS(s.js.pairs(s.mp.at(0))),pop:s=>s.js.pop(),push:s=>s.js.push(s.mp),push1:s=>s.js.push(s.mp.at(0)),redact:s=>s.js.redact(...s.mp.indexValues()),reverse:s=>s.js.reverse(),rio:O,self:s=>s.js,set:h,setter:w,shift:s=>s.js.shift(),size:s=>s.js.size,toJSON:s=>s.js.toJSON(),toReversed:s=>s.js.toReversed(),toSLID:s=>s.js.toSLID(s.mp?.storage||{}),toString:s=>s.js.toString(s.mp?.storage||{}),unshift:s=>s.js.unshift(s.mp),values:s=>new NANOS([...s.js.values()])},cacheHints:{"@init":"pin",at:"pin",has:"pin",nset:"pin",set:"pin"}})}export{d as install};
