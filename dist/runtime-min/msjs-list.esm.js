import{getInstance as h,getInterface as m,runIfCode as l,setRO as c}from"./runtime.esm.js";import{unifiedList as u,uniAt as N}from"./unified-list.esm.js";function y(s){const{octx:t,mp:n}=s,e=n.at(0);c(t,"js",e instanceof NANOS?e:new NANOS),c(s.js,$c.symbols.instance,s.rr,!1)}function p(s){const{mp:t}=s,n=t.has("path")?u(t.at("path")).values():t.values();return N(s.js,[...n],{wrap:!0,defaultFn:()=>{if(t.has("else"))return l(t.at("else"));throw new Error("Key path not found")}})}function k(){if(this.list.has(this.key))return this.list.at(this.key);if(this.hasElse)return l(this.elseVal);throw new Error(`Required key ${this.key} not present`)}function S(s){const{js:t,mp:n}=s,e=n.at(0),a=n.has("else"),i=n.at("else");return s.b({cd:k.bind({list:t,key:e,hasElse:a,elseVal:i})})}function O(s){return s.mp.has(0)?(s.js.next=s.mp.at(0),s.rr):s.js.next}function f(s){const{mp:t,js:n}=s;for(const e of t.entries())n.set(e[0],e[1])}function A(s){const{js:t,mp:n}=s;if(n.has(0)){let e=n.at(0);return e===!0&&(e=h("@reactive")("rio")),t.rio=e,s.rr}return!!t.rio}function w(s){this.list.set(this.key,s.mp.at(0))}function x(s){const{js:t,mp:n}=s,e=n.at(0);return s.b({cd:w.bind({list:t,key:e})})("fn")}const v=s=>{const t=typeof s;return t==="string"||t==="number"||t==="symbol"};function j(s){const{mp:t}=s,e=[...t.has("path")?u(t.at("path")).values():t.values()].filter(r=>v(r)),a=e.length-(t.has("to")?1:0);let i=s.js;for(let r=0;r<a;++r){const o=e[r];i.at(o)instanceof NANOS||i.set(o,i.similar()),i=i.at(o)}t.has("to")?i.set(e[a],t.at("to"),t.at("insert")):(t.has("first")&&i.unshift(t.at("first")),t.has("next")&&i.push(t.at("next")))}function K(s){m(s).set({lock:!0,pristine:!0,handlers:{"@init":y,"@jsv":t=>t.js,"@":p,"==":f,">":t=>t.js.pop(),"|+":t=>t.js.push(t.mp),"=":j,"<":t=>t.js.shift(),"+|":t=>t.js.unshift(t.mp),at:p,clear:t=>t.js.clear(),copy:t=>new NANOS().fromPairs(t.js.pairs()),delete:t=>t.js.delete(t.mp.at(0)),depend:t=>t.js.depend(),entries:t=>new NANOS([...t.js.entries()]),get:p,getter:S,has:t=>t.js.has(t.mp.at(0)),includes:t=>t.js.includes(t.mp.at(0)),indexEntries:t=>new NANOS([...t.js.indexEntries(t.mp.at(0))]),indexKeys:t=>new NANOS([...t.js.indexKeys()]),isLocked:t=>t.js.isLocked(t.mp.at(0)),isRedacted:t=>t.js.isRedacted(t.mp.at(0)),keyOf:t=>t.js.keyOf(t.mp.at(0)),keyIter:t=>t.js.keys(),keys:t=>new NANOS([...t.js.keys()]),lastKeyOf:t=>t.js.lastKeyOf(t.mp.at(0)),lock:t=>t.js.lock(...t.mp.indexValues()),lockAll:t=>t.js.lockAll(t.mp.at(0)),lockKeys:t=>t.js.lockKeys(),namedEntries:t=>new NANOS([...t.js.namedEntries()]),namedKeys:t=>new NANOS([...t.js.namedKeys()]),next:O,nset:f,pairs:t=>new NANOS(t.js.pairs(t.mp.at(0))),pop:t=>t.js.pop(),push:t=>t.js.push(t.mp),push1:t=>t.js.push(t.mp.at(0)),redact:t=>t.js.redact(...t.mp.indexValues()),reverse:t=>t.js.reverse(),rio:A,self:t=>t.js,set:j,setter:x,shift:t=>t.js.shift(),size:t=>t.js.size,toJSON:t=>t.js.toJSON(),toReversed:t=>t.js.toReversed(),toSLID:t=>t.js.toSLID(t.mp?.storage||{}),toString:t=>t.js.toString(t.mp?.storage||{}),unshift:t=>t.js.unshift(t.mp),values:t=>new NANOS([...t.js.values()])},cacheHints:{"@init":"pin",at:"pin",has:"pin",nset:"pin",set:"pin"}})}export{K as install};
