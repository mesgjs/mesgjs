import{getInstance as h,getInterface as m,runIfCode as l,setRO as c}from"./runtime.esm.js";import{unifiedList as u,uniAt as N}from"./unified-list.esm.js";function y(s){const{octx:t,mp:n}=s,e=n.at(0);c(t,"js",e instanceof NANOS?e:new NANOS),c(s.rr,{jsv:s.js,valueOf:()=>s.js})}function p(s){const{mp:t}=s,n=t.has("path")?u(t.at("path")).values():t.values();return N(s.js,[...n],{wrap:!0,raw:t.at("raw"),defaultFn:()=>{if(t.has("else"))return l(t.at("else"));throw new Error("Key path not found")}})}function k(){if(this.list.has(this.key))return this.list.at(this.key);if(this.hasElse)return l(this.elseVal);throw new Error(`Required key ${this.key} not present`)}function O(s){const{js:t,mp:n}=s,e=n.at(0),a=n.has("else"),i=n.at("else");return s.b({cd:k.bind({list:t,key:e,hasElse:a,elseVal:i})})}function S(s){return s.mp.has(0)?(s.js.next=s.mp.at(0),s.rr):s.js.next}function j(s){const{mp:t,js:n}=s;for(const e of t.entries())n.set(e[0],e[1])}function w(s){const{js:t,mp:n}=s;if(n.has(0)){let e=n.at(0);return e===!0&&(e=h("@reactive")("rio")),t.rio=e,s.rr}return!!t.rio}function A(s){this.list.set(this.key,s.mp.at(0),{raw:s.mp.at("raw")})}function v(s){const{js:t,mp:n}=s,e=n.at(0);return s.b({cd:A.bind({list:t,key:e})})("fn")}const x=s=>{const t=typeof s;return t==="string"||t==="number"||t==="symbol"};function f(s){const{mp:t}=s,e=[...t.has("path")?u(t.at("path")).values():t.values()].filter(r=>x(r)),a=e.length-(t.has("to")?1:0);let i=s.js;for(let r=0;r<a;++r){const o=e[r];i.at(o)instanceof NANOS||i.set(o,i.similar()),i=i.at(o)}t.has("to")?i.set(e[a],t.at("to"),t.at("insert")):(t.has("first")&&i.unshift(t.at("first")),t.has("next")&&i.push(t.at("next")))}function d(s){m(s).set({lock:!0,pristine:!0,handlers:{"@init":y,"@jsv":t=>t.js,"@":p,"==":j,">":t=>t.js.pop(),"|+":t=>t.js.push(t.mp),"=":f,"<":t=>t.js.shift(),"+|":t=>t.js.unshift(t.mp),at:p,clear:t=>t.js.clear(),copy:t=>new NANOS().fromPairs(t.js.pairs()),delete:t=>t.js.delete(t.mp.at(0)),depend:t=>t.js.depend(),entries:t=>new NANOS([...t.js.entries()]),get:p,getter:O,has:t=>t.js.has(t.mp.at(0)),includes:t=>t.js.includes(t.mp.at(0)),indexEntries:t=>new NANOS([...t.js.indexEntries(t.mp.at(0))]),indexKeys:t=>new NANOS([...t.js.indexKeys()]),isLocked:t=>t.js.isLocked(t.mp.at(0)),isRedacted:t=>t.js.isRedacted(t.mp.at(0)),keyOf:t=>t.js.keyOf(t.mp.at(0)),keyIter:t=>t.js.keys(),keys:t=>new NANOS([...t.js.keys()]),lastKeyOf:t=>t.js.lastKeyOf(t.mp.at(0)),lock:t=>t.js.lock(...t.mp.indexValues()),lockAll:t=>t.js.lockAll(t.mp.at(0)),lockKeys:t=>t.js.lockKeys(),namedEntries:t=>new NANOS([...t.js.namedEntries()]),namedKeys:t=>new NANOS([...t.js.namedKeys()]),next:S,nset:j,pairs:t=>new NANOS(t.js.pairs(t.mp.at(0))),pop:t=>t.js.pop(),push:t=>t.js.push(t.mp),push1:t=>t.js.push(t.mp.at(0)),redact:t=>t.js.redact(...t.mp.indexValues()),reverse:t=>t.js.reverse(),rio:w,self:t=>t.js,set:f,setter:v,shift:t=>t.js.shift(),size:t=>t.js.size,toJSON:t=>t.js.toJSON(),toReversed:t=>t.js.toReversed(),toSLID:t=>t.js.toSLID(t.mp?.storage||{}),toString:t=>t.js.toString(t.mp?.storage||{}),unshift:t=>t.js.unshift(t.mp),values:t=>new NANOS([...t.js.values()])},cacheHints:{"@init":"pin",at:"pin",has:"pin",nset:"pin",set:"pin"}})}export{d as install};
