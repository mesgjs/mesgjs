{
  "version": 3,
  "sources": ["../../src/runtime/sieve-cache.esm.js"],
  "sourcesContent": ["/*\n * SIEVE Cache Implementation\n * (with option to pin additional entries)\n * Authors: Chat GPT and Brian Katzung\n */\n\nexport class SieveEntry {\n    constructor (key, value) {\n\tthis.key = key;\n\tthis.value = value;\n\tthis.ref = false;\n\tthis.next = null;\n    }\n}\n\nexport class SieveCache {\n    constructor (capacity = 256) {\n\tthis.capacity = capacity;\n\tthis.map = new Map();\t// key -> entry\n\tthis.hand = null;\t// eviction pointer\n\tthis.size = 0;\n    }\n\n    clear () {\n\tthis.map.clear();\n\tthis.hand = null;\n\tthis.size = 0;\n    }\n\n    _evictAndInsert (newEntry) {\n\tlet scanned = 0;\n\twhile (scanned < this.capacity) {\n\t    const candidate = this.hand.next;\n\t    if (!candidate.ref) {\n\t\t// Evict\n\t\tthis.map.delete(candidate.key);\n\t\tnewEntry.next = candidate.next;\n\t\tthis.hand.next = newEntry;\n\t\t// Replace candidate\n\t\treturn;\n\t    } else {\n\t\tcandidate.ref = false;\n\t\tthis.hand = candidate;\n\t\tscanned++;\n\t    }\n\t}\n\n\t// All were recently used - replace next anyway (fallback policy)\n\tconst fallback = this.hand.next;\n\tthis.map.delete(fallback.key);\n\tnewEntry.next = fallback.next;\n\tthis.hand.next = newEntry;\n    }\n\n    get (key) {\n\tconst entry = this.map.get(key);\n\tif (entry) {\n\t    entry.ref = true;\n\t    return entry.value;\n\t}\n    }\n\n    has (key) { return this.map.has(key); }\n\n    _insert (entry) {\n\tif (!this.hand) {\n\t    entry.next = entry;\n\t    this.hand = entry;\n\t} else {\n\t    entry.next = this.hand.next;\n\t    this.hand.next = entry;\n\t}\n    }\n\n    // Keys iterator\n    keys () { return this.map.keys(); }\n\n    set (key, value, pinned = false) {\n\tlet entry = this.map.get(key);\n\n\tif (entry) {\n\t    entry.value = value;\n\t    entry.ref = true;\n\t    return;\n\t}\n\n\tentry = new SieveEntry(key, value);\n\n\tif (!pinned) {\n\t    // Pinned entries aren't counted and will never be evicted\n\t    if (this.size < this.capacity) {\n\t\tthis._insert(entry);\n\t\tthis.size++;\n\t    } else {\n\t\tthis._evictAndInsert(entry);\n\t    }\n\t}\n\n\tthis.map.set(key, entry);\n    }\n}\n\nexport { SieveCache as default };\n\n// END\n"],
  "mappings": "AAMO,MAAMA,CAAW,CACpB,YAAaC,EAAKC,EAAO,CAC5B,KAAK,IAAMD,EACX,KAAK,MAAQC,EACb,KAAK,IAAM,GACX,KAAK,KAAO,IACT,CACJ,CAEO,MAAMC,CAAW,CACpB,YAAaC,EAAW,IAAK,CAChC,KAAK,SAAWA,EAChB,KAAK,IAAM,IAAI,IACf,KAAK,KAAO,KACZ,KAAK,KAAO,CACT,CAEA,OAAS,CACZ,KAAK,IAAI,MAAM,EACf,KAAK,KAAO,KACZ,KAAK,KAAO,CACT,CAEA,gBAAiBC,EAAU,CAC9B,IAAIC,EAAU,EACd,KAAOA,EAAU,KAAK,UAAU,CAC5B,MAAMC,EAAY,KAAK,KAAK,KAC5B,GAAKA,EAAU,IAQlBA,EAAU,IAAM,GAChB,KAAK,KAAOA,EACZD,QAVuB,CAEvB,KAAK,IAAI,OAAOC,EAAU,GAAG,EAC7BF,EAAS,KAAOE,EAAU,KAC1B,KAAK,KAAK,KAAOF,EAEjB,MACG,CAKJ,CAGA,MAAMG,EAAW,KAAK,KAAK,KAC3B,KAAK,IAAI,OAAOA,EAAS,GAAG,EAC5BH,EAAS,KAAOG,EAAS,KACzB,KAAK,KAAK,KAAOH,CACd,CAEA,IAAKJ,EAAK,CACb,MAAMQ,EAAQ,KAAK,IAAI,IAAIR,CAAG,EAC9B,GAAIQ,EACA,OAAAA,EAAM,IAAM,GACLA,EAAM,KAEd,CAEA,IAAKR,EAAK,CAAE,OAAO,KAAK,IAAI,IAAIA,CAAG,CAAG,CAEtC,QAASQ,EAAO,CACd,KAAK,MAINA,EAAM,KAAO,KAAK,KAAK,KACvB,KAAK,KAAK,KAAOA,IAJjBA,EAAM,KAAOA,EACb,KAAK,KAAOA,EAKb,CAGA,MAAQ,CAAE,OAAO,KAAK,IAAI,KAAK,CAAG,CAElC,IAAKR,EAAKC,EAAOQ,EAAS,GAAO,CACpC,IAAID,EAAQ,KAAK,IAAI,IAAIR,CAAG,EAE5B,GAAIQ,EAAO,CACPA,EAAM,MAAQP,EACdO,EAAM,IAAM,GACZ,MACJ,CAEAA,EAAQ,IAAIT,EAAWC,EAAKC,CAAK,EAE5BQ,IAEG,KAAK,KAAO,KAAK,UACxB,KAAK,QAAQD,CAAK,EAClB,KAAK,QAEL,KAAK,gBAAgBA,CAAK,GAI3B,KAAK,IAAI,IAAIR,EAAKQ,CAAK,CACpB,CACJ",
  "names": ["SieveEntry", "key", "value", "SieveCache", "capacity", "newEntry", "scanned", "candidate", "fallback", "entry", "pinned"]
}
