{
  "version": 3,
  "sources": ["../../src/runtime/sieve-cache.esm.js"],
  "sourcesContent": ["/*\n * SIEVE Cache Implementation\n * (with option to pin additional entries)\n * Authors: Chat GPT and Brian Katzung\n */\n\nexport class SieveEntry {\n    constructor (key, value) {\n        this.key = key;\n        this.value = value;\n        this.ref = false;\n        this.next = null;\n    }\n}\n\nexport class SieveCache {\n    constructor (capacity = 256) {\n        this.capacity = capacity;\n        this.map = new Map();\t// key -> entry\n        this.hand = null;\t// eviction pointer\n        this.size = 0;\n    }\n\n    clear () {\n        this.map.clear();\n        this.hand = null;\n        this.size = 0;\n    }\n\n    _evictAndInsert (newEntry) {\n        let scanned = 0;\n        while (scanned < this.capacity) {\n            const candidate = this.hand.next;\n            if (!candidate.ref) {\n                // Evict\n                this.map.delete(candidate.key);\n                newEntry.next = candidate.next;\n                this.hand.next = newEntry;\n                // Replace candidate\n                return;\n            } else {\n                candidate.ref = false;\n                this.hand = candidate;\n                scanned++;\n            }\n        }\n\n        // All were recently used - replace next anyway (fallback policy)\n        const fallback = this.hand.next;\n        this.map.delete(fallback.key);\n        newEntry.next = fallback.next;\n        this.hand.next = newEntry;\n    }\n\n    get (key) {\n        const entry = this.map.get(key);\n        if (entry) {\n            entry.ref = true;\n            return entry.value;\n        }\n    }\n\n    has (key) { return this.map.has(key); }\n\n    _insert (entry) {\n        if (!this.hand) {\n            entry.next = entry;\n            this.hand = entry;\n        } else {\n            entry.next = this.hand.next;\n            this.hand.next = entry;\n        }\n    }\n\n    // Keys iterator\n    keys () { return this.map.keys(); }\n\n    set (key, value, pinned = false) {\n        let entry = this.map.get(key);\n\n        if (entry) {\n            entry.value = value;\n            entry.ref = true;\n            return;\n        }\n\n        entry = new SieveEntry(key, value);\n\n\tif (!pinned) {\n\t    // Pinned entries aren't counted and will never be evicted\n\t    if (this.size < this.capacity) {\n\t\tthis._insert(entry);\n\t\tthis.size++;\n\t    } else {\n\t\tthis._evictAndInsert(entry);\n\t    }\n\t}\n\n        this.map.set(key, entry);\n    }\n}\n\nexport { SieveCache as default };\n\n// END\n"],
  "mappings": "AAMO,MAAMA,CAAW,CACpB,YAAaC,EAAKC,EAAO,CACrB,KAAK,IAAMD,EACX,KAAK,MAAQC,EACb,KAAK,IAAM,GACX,KAAK,KAAO,IAChB,CACJ,CAEO,MAAMC,CAAW,CACpB,YAAaC,EAAW,IAAK,CACzB,KAAK,SAAWA,EAChB,KAAK,IAAM,IAAI,IACf,KAAK,KAAO,KACZ,KAAK,KAAO,CAChB,CAEA,OAAS,CACL,KAAK,IAAI,MAAM,EACf,KAAK,KAAO,KACZ,KAAK,KAAO,CAChB,CAEA,gBAAiBC,EAAU,CACvB,IAAIC,EAAU,EACd,KAAOA,EAAU,KAAK,UAAU,CAC5B,MAAMC,EAAY,KAAK,KAAK,KAC5B,GAAKA,EAAU,IAQXA,EAAU,IAAM,GAChB,KAAK,KAAOA,EACZD,QAVgB,CAEhB,KAAK,IAAI,OAAOC,EAAU,GAAG,EAC7BF,EAAS,KAAOE,EAAU,KAC1B,KAAK,KAAK,KAAOF,EAEjB,MACJ,CAKJ,CAGA,MAAMG,EAAW,KAAK,KAAK,KAC3B,KAAK,IAAI,OAAOA,EAAS,GAAG,EAC5BH,EAAS,KAAOG,EAAS,KACzB,KAAK,KAAK,KAAOH,CACrB,CAEA,IAAKJ,EAAK,CACN,MAAMQ,EAAQ,KAAK,IAAI,IAAIR,CAAG,EAC9B,GAAIQ,EACA,OAAAA,EAAM,IAAM,GACLA,EAAM,KAErB,CAEA,IAAKR,EAAK,CAAE,OAAO,KAAK,IAAI,IAAIA,CAAG,CAAG,CAEtC,QAASQ,EAAO,CACP,KAAK,MAINA,EAAM,KAAO,KAAK,KAAK,KACvB,KAAK,KAAK,KAAOA,IAJjBA,EAAM,KAAOA,EACb,KAAK,KAAOA,EAKpB,CAGA,MAAQ,CAAE,OAAO,KAAK,IAAI,KAAK,CAAG,CAElC,IAAKR,EAAKC,EAAOQ,EAAS,GAAO,CAC7B,IAAID,EAAQ,KAAK,IAAI,IAAIR,CAAG,EAE5B,GAAIQ,EAAO,CACPA,EAAM,MAAQP,EACdO,EAAM,IAAM,GACZ,MACJ,CAEAA,EAAQ,IAAIT,EAAWC,EAAKC,CAAK,EAEnCQ,IAEG,KAAK,KAAO,KAAK,UACxB,KAAK,QAAQD,CAAK,EAClB,KAAK,QAEL,KAAK,gBAAgBA,CAAK,GAIpB,KAAK,IAAI,IAAIR,EAAKQ,CAAK,CAC3B,CACJ",
  "names": ["SieveEntry", "key", "value", "SieveCache", "capacity", "newEntry", "scanned", "candidate", "fallback", "entry", "pinned"]
}
