{
  "version": 3,
  "sources": ["../../src/runtime/sieve-cache.esm.js"],
  "sourcesContent": ["/*\n * SIEVE Cache Implementation\n * (with option to pin additional entries)\n * Authors: Chat GPT and Brian Katzung\n */\n\nexport class SieveEntry {\n\tconstructor (key, value) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t\tthis.ref = false;\n\t\tthis.next = null;\n\t}\n}\n\nexport class SieveCache {\n\tconstructor (capacity = 256) {\n\t\tthis.capacity = capacity;\n\t\tthis.map = new Map();\t// key -> entry\n\t\tthis.hand = null;\t\t// eviction pointer\n\t\tthis.size = 0;\n\t}\n\n\tclear () {\n\t\tthis.map.clear();\n\t\tthis.hand = null;\n\t\tthis.size = 0;\n\t}\n\n\t_evictAndInsert (newEntry) {\n\t\tlet scanned = 0;\n\t\twhile (scanned < this.capacity) {\n\t\t\tconst candidate = this.hand.next;\n\t\t\tif (!candidate.ref) {\n\t\t\t\t// Evict\n\t\t\t\tthis.map.delete(candidate.key);\n\t\t\t\tnewEntry.next = candidate.next;\n\t\t\t\tthis.hand.next = newEntry;\n\t\t\t\t// Replace candidate\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tcandidate.ref = false;\n\t\t\t\tthis.hand = candidate;\n\t\t\t\tscanned++;\n\t\t\t}\n\t\t}\n\n\t\t// All were recently used - replace next anyway (fallback policy)\n\t\tconst fallback = this.hand.next;\n\t\tthis.map.delete(fallback.key);\n\t\tnewEntry.next = fallback.next;\n\t\tthis.hand.next = newEntry;\n\t}\n\n\tget (key) {\n\t\tconst entry = this.map.get(key);\n\t\tif (entry) {\n\t\t\tentry.ref = true;\n\t\t\treturn entry.value;\n\t\t}\n\t}\n\n\thas (key) { return this.map.has(key); }\n\n\t_insert (entry) {\n\t\tif (!this.hand) {\n\t\t\tentry.next = entry;\n\t\t\tthis.hand = entry;\n\t\t} else {\n\t\t\tentry.next = this.hand.next;\n\t\t\tthis.hand.next = entry;\n\t\t}\n\t}\n\n\t// Keys iterator\n\tkeys () { return this.map.keys(); }\n\n\tset (key, value, pinned = false) {\n\t\tlet entry = this.map.get(key);\n\n\t\tif (entry) {\n\t\t\tentry.value = value;\n\t\t\tentry.ref = true;\n\t\t\treturn;\n\t\t}\n\n\t\tentry = new SieveEntry(key, value);\n\n\t\tif (!pinned) {\n\t\t\t// Pinned entries aren't counted and will never be evicted\n\t\t\tif (this.size < this.capacity) {\n\t\t\t\tthis._insert(entry);\n\t\t\t\tthis.size++;\n\t\t\t} else {\n\t\t\t\tthis._evictAndInsert(entry);\n\t\t\t}\n\t\t}\n\n\t\tthis.map.set(key, entry);\n\t}\n}\n\nexport { SieveCache as default };\n\n// END\n"],
  "mappings": "AAMO,MAAMA,CAAW,CACvB,YAAaC,EAAKC,EAAO,CACxB,KAAK,IAAMD,EACX,KAAK,MAAQC,EACb,KAAK,IAAM,GACX,KAAK,KAAO,IACb,CACD,CAEO,MAAMC,CAAW,CACvB,YAAaC,EAAW,IAAK,CAC5B,KAAK,SAAWA,EAChB,KAAK,IAAM,IAAI,IACf,KAAK,KAAO,KACZ,KAAK,KAAO,CACb,CAEA,OAAS,CACR,KAAK,IAAI,MAAM,EACf,KAAK,KAAO,KACZ,KAAK,KAAO,CACb,CAEA,gBAAiBC,EAAU,CAC1B,IAAIC,EAAU,EACd,KAAOA,EAAU,KAAK,UAAU,CAC/B,MAAMC,EAAY,KAAK,KAAK,KAC5B,GAAKA,EAAU,IAQdA,EAAU,IAAM,GAChB,KAAK,KAAOA,EACZD,QAVmB,CAEnB,KAAK,IAAI,OAAOC,EAAU,GAAG,EAC7BF,EAAS,KAAOE,EAAU,KAC1B,KAAK,KAAK,KAAOF,EAEjB,MACD,CAKD,CAGA,MAAMG,EAAW,KAAK,KAAK,KAC3B,KAAK,IAAI,OAAOA,EAAS,GAAG,EAC5BH,EAAS,KAAOG,EAAS,KACzB,KAAK,KAAK,KAAOH,CAClB,CAEA,IAAKJ,EAAK,CACT,MAAMQ,EAAQ,KAAK,IAAI,IAAIR,CAAG,EAC9B,GAAIQ,EACH,OAAAA,EAAM,IAAM,GACLA,EAAM,KAEf,CAEA,IAAKR,EAAK,CAAE,OAAO,KAAK,IAAI,IAAIA,CAAG,CAAG,CAEtC,QAASQ,EAAO,CACV,KAAK,MAITA,EAAM,KAAO,KAAK,KAAK,KACvB,KAAK,KAAK,KAAOA,IAJjBA,EAAM,KAAOA,EACb,KAAK,KAAOA,EAKd,CAGA,MAAQ,CAAE,OAAO,KAAK,IAAI,KAAK,CAAG,CAElC,IAAKR,EAAKC,EAAOQ,EAAS,GAAO,CAChC,IAAID,EAAQ,KAAK,IAAI,IAAIR,CAAG,EAE5B,GAAIQ,EAAO,CACVA,EAAM,MAAQP,EACdO,EAAM,IAAM,GACZ,MACD,CAEAA,EAAQ,IAAIT,EAAWC,EAAKC,CAAK,EAE5BQ,IAEA,KAAK,KAAO,KAAK,UACpB,KAAK,QAAQD,CAAK,EAClB,KAAK,QAEL,KAAK,gBAAgBA,CAAK,GAI5B,KAAK,IAAI,IAAIR,EAAKQ,CAAK,CACxB,CACD",
  "names": ["SieveEntry", "key", "value", "SieveCache", "capacity", "newEntry", "scanned", "candidate", "fallback", "entry", "pinned"]
}
