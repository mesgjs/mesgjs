{
  "version": 3,
  "sources": ["../../src/runtime/msjs-core.esm.js"],
  "sourcesContent": ["/*\n * Mesgjs @core Interface\n * Author: Brian Katzung <briank@kappacs.com>\n * Copyright 2025 by Kappa Computer Solutions, LLC and Brian Katzung\n */\n\nimport { debugConfig, fcheck, fready, fwait, getInstance, getInterface, logInterfaces, runIfCode, setRO, typeAccepts, typeChains } from './runtime.esm.js';\nimport { NANOS, parseQJSON, parseSLID } from './vendor.esm.js';\n\n// (and value...)\n// And: false result if any not true, else last true result (default true)\nfunction opAnd (d) {\n    const { mp } = d;\n    let result = true;\n    for (const v of mp.values()) {\n\tresult = runIfCode(v);\n\tif (!result) return result;\n    }\n    return result;\n}\n\n// (case val cmp1 res1 ... cmpN resN else=default)\nfunction opCase (d) {\n    const { mp } = d, val = mp.at(0), type = val?.msjsType, stop = mp.next - 1;\n    const op = typeAccepts(type, 'caseEq') ? 'caseEq' : typeAccepts(type, 'eq') ? 'eq' : undefined, eq = op ? (to => val(op, to)) : (to => val === to);\n    for (let i = 1; i < stop; i += 2) if (eq(runIfCode(mp.at(i)))) return runIfCode(mp.at(i + 1));\n    return runIfCode(mp.at('else'));\n}\n\n// (get type init=params)\nfunction opGet (d) {\n    const { mp } = d;\n    return getInstance(mp.at(0), mp.at('init'));\n}\n\n// (if cond1 then1 cond2 then2 ... else=value)\nfunction opIf (d) {\n    const { mp } = d, end = mp.next - 1;\n    for (let i = 0; i < end; i += 2) if (runIfCode(mp.at(i))) return runIfCode(mp.at(i + 1));\n    /*\n     * Return the else value if provided; otherwise return the final\n     * expression if there's an odd number of expressions.\n     */\n    if (mp.has('else')) return runIfCode(mp.at('else'));\n    if (mp.next % 2) return runIfCode(mp.at(end));\n}\n\n// function opImport (d) {\n// }\n\n// (or value...)\n// Or: first true result, else last false result (default false)\nfunction opOr (d) {\n    const { mp } = d;\n    let result = false;\n    for (const v of mp.values()) {\n\tresult = runIfCode(v);\n\tif (result) return result;\n    }\n    return result;\n}\n\n// (run value... collect=@f)\n\nfunction opRun (d) {\n    const { mp } = d, collect = mp.at('collect');\n    let result = collect ? new NANOS() : undefined;\n    const save = v => { if (collect) result.push(v); else result = v; };\n    if (mp.at('repeat')) for (const v of mp.values()) save(runWhileCode(v));\n    else for (const v of mp.values()) save(runIfCode(v));\n    return result;\n}\n\n// (throw error)\nfunction opThrow (d) {\n    const { mp } = d, err = mp.at(0);\n    throw ((err instanceof Error) ? err : new Error(err));\n}\n\nfunction opXor (d) {\n    const { mp } = d;\n    let result = false;\n    for (const v of mp.values()) {\n\tconst curRes = runIfCode(v);\n\tif (curRes) {\n\t    if (result) return false;\n\t    result = curRes;\n\t}\n    }\n    return result;\n}\n\nfunction runWhileCode (v) {\n    while (v?.msjsType === '@code') v = v('run');\n    return v;\n}\n\nexport function install (name) {\n    getInterface(name).set({\n\tfinal: true, lock: true, pristine: true, singleton: true,\n\thandlers: {\n\t    _: d => d.mp.at(0),\t\t// underscore (\"basically parentheses\")\n\t    and: opAnd,\n\t    case: opCase,\n\t    debug: d => debugConfig(d.mp),\n\t    fcheck: d => fcheck(d.mp.at(0)),\n\t    fwait: d => fwait(...d.mp.values()),\n\t    fready: d => fready(d.mp.at('mid'), d.mp.at(0)),\n\t    get: opGet,\t\t\t// Get instance\n\t    if: opIf,\n\t    // import: opImport,\n\t    interface: d => getInterface(d.mp.at(0)),\n\t    log: d => console.log(...d.mp.values()),\n\t    logErr: d => console.error(...d.mp.values()),\n\t    logInterfaces,\n\t    logWarn: d => console.warn(...d.mp.values()),\n\t    not: d => !runIfCode(d.mp.at(0)),\n\t    or: opOr,\n\t    qjson: d => parseQJSON(d.mp.at(0, '')),\n\t    run: opRun,\n\t    slid: d => parseSLID(d.mp.at(0, '')),\n\t    throw: opThrow,\n\t    type: d => globalThis.$toMSJS(d.mp.at(0))?.msjsType,\n\t    typeAccepts: d => typeAccepts(d.mp.at(0), d.mp.at(1)),\n\t    typeChains: d => typeChains(d.mp.at(0), d.mp.at(1)),\n\t    xor: opXor,\n\t},\n\tcacheHints: {\n\t    case: 'pin',\n\t    get: 'pin',\n\t    if: 'pin',\n\t},\n    });\n    if (name === '@core') setRO(globalThis, '$c', getInstance('@core'));\n}\n\n// END\n"],
  "mappings": "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",
  "names": ["debugConfig", "fcheck", "fready", "fwait", "getInstance", "getInterface", "logInterfaces", "runIfCode", "setRO", "typeAccepts", "typeChains", "NANOS", "parseQJSON", "parseSLID", "opAnd", "d", "mp", "result", "v", "opCase", "val", "type", "stop", "op", "eq", "to", "i", "opGet", "opIf", "end", "opOr", "opRun", "collect", "save", "runWhileCode", "opThrow", "err", "opXor", "curRes", "install", "name"]
}
