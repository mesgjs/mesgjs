import{getInstance as w,getInterface as v,setRO as A}from"./runtime.esm.js";import{NANOS as p}from"./vendor.esm.js";const d=e=>e,b=e=>{throw e},m=e=>typeof e=="function"&&(!e.msjsType||e.msjsType==="@code"||e.msjsType==="@function"),E=e=>typeof e?.then=="function",i=Symbol(),g=e=>Object.assign(new p(e),e);function c(e){if(Array.isArray(e))return e;if(typeof e?.[Symbol.iterator]=="function"||typeof e?.next=="function")return Array.from(e);if(typeof e?.values=="function")return[...e.values()]}function f(e){const{state:t,result:r}=this[i],s=t==="fulfilled";if(!s&&!e.length){queueMicrotask(()=>Promise.reject(r));return}for(const l of e){const[a,n,h]=l;queueMicrotask(()=>{try{const o=s?a:n,y=o.msjsType;if(y){const j=s?{state:t,resolve:r}:{state:t,reject:r,message:r?.message};h.resolve(o(y==="@code"?"run":"call",j))}else h.resolve(o(r))}catch(o){h.reject(o)}})}}const u=Object.setPrototypeOf({all(e,t=!1){if(this[i].state!=="pending")return;if(this[i].toList=t,e=c(e),!Array.isArray(e))throw new TypeError("@promise(all) requires an iterable of promises");const r=[];let s=e.length;return s||this.resolve(r),e.forEach((l,a)=>{l.then(n=>{r[a]=n,--s===0&&this.resolve(r)},n=>this.reject(n))}),this},allSettled(e,t=!1){if(this[i].state!=="pending")return;if(this[i].toList=t,e=c(e),!Array.isArray(e))throw new TypeError("@promise(allSettled) requires an iterable of promises");const r=[];let s=e.length;return s||this.resolve(r),e.forEach((l,a)=>{l.then(n=>{r[a]=g({status:"fulfilled",value:n}),--s===0&&this.resolve(r)},n=>{r[a]=g({status:"rejected",reason:n}),--s===0&&this.resolve(r)})}),this},always(e){return this.then(e,e)},any(e){if(this[i].state!=="pending")return;if(e=c(e),!Array.isArray(e))throw new TypeError("@promise(any) requires an iterable of promises");const t=[];let r=e.length;const s=()=>this.reject(new AggregateError(t,"All promises were rejected"));return r||s(),e.forEach((l,a)=>{l.then(n=>this.resolve(n),n=>{t[a]=n,--r===0&&s()})}),this},catch(e){return this.then(null,e)},then(e,t){const r=this[i];m(e)||(e=d),m(t)||(t=b);const s=[e,t,w("@promise")];return r.handlers?r.handlers.push(s):queueMicrotask(()=>f.call(this,[s])),s[2]},race(e){if(this[i].state==="pending"){if(e=c(e),!Array.isArray(e))throw new TypeError("@promise(race) requires an iterable of promises");return e.forEach(t=>t.then(r=>this.resolve(r),r=>this.reject(r))),this}},reject(e){const t=this[i];t.state==="pending"&&(t.state="rejected",e instanceof Error||(e=new Error(e)),t.result=e,queueMicrotask(()=>{f.call(this,t.handlers),t.handlers=null}))},resolve(e){const t=this[i];if(t.state==="pending"){if(E(e)){e.then(r=>this.resolve(r),r=>this.reject(r));return}t.state="fulfilled",t.result=t.toList&&Array.isArray(e)?new p(e):e,queueMicrotask(()=>{f.call(this,t.handlers),t.handlers=null})}},get result(){return this[i].result},get state(){return this[i].state}},Object.getPrototypeOf(Function));u.finally=u.always;function q(e){Object.setPrototypeOf(e.rr,u),A(e.rr,i,{state:"pending",result:void 0,handlers:[]}),e.mp.has("resolve")&&e.rr.resolve(e.mp.at("resolve")),e.mp.has("reject")&&e.rr.reject(e.mp.at("reject"))}function T(e){v(e).set({lock:!0,pristine:!0,handlers:{"@init":q,all:t=>t.rr.all(t.mp,!0),allSettled:t=>t.rr.allSettled(t.mp,!0),always:t=>t.rr.always(t.mp.at(0)),any:t=>t.rr.any(t.mp),catch:t=>t.rr.catch(t.mp.at(0)),message:t=>t.rr.result?.message,race:t=>t.rr.race(t.mp),reject:t=>t.rr.reject(t.mp.at(0)),resolve:t=>t.rr.resolve(t.mp.at(0)),result:t=>t.rr.result,state:t=>t.rr.state,then:t=>t.rr.then(t.mp.at(0),t.mp.at(1))}})}export{T as install};
